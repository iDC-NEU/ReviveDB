#pragma once
#include "boost/core/noncopyable.hpp"
#include "common/nvm_types.h"
#include "scrambled_zipfian_generator.h"
#include "ycsb_def.h"
#include <cstddef>
#include <thread>
#include <vector>
#include <unordered_map>
namespace NVMDB {
namespace YCSB {

struct Operation {
    enum class OpType {
        Read,
        Write,
    };

    OpType m_opType;
    RowId m_pKey;
    // for write
    bool m_genBySkew;  // INFO: simply show if it is generated by zipfian generator
    ColumnIdx m_colIdx;
    char *m_colValue;  // 总是不会持有数据
};
// 生成rowId
class UnCachedRowIdGenerator : boost::noncopyable {
public:
    UnCachedRowIdGenerator(ScrambledZipfianGenerator *szipfian, const YcsbTableParam &tableParam,
                           const YcsbRunParam &runParam)
        : m_skewRowId(szipfian),
          m_uniformRowIds(runParam.Terminal, std::uniform_int_distribution<RowId>(0, tableParam.Items - 1)),
          m_tableParam(tableParam),
          m_runParam(runParam)
    {}
    std::vector<std::pair<RowId, bool>> operator()(size_t threadId)
    {
        std::unordered_map<RowId, bool> res;
        res.reserve(OpPerTxn);
        while (res.size() < m_runParam.SkewOpPerTxn) {
            res[m_skewRowId->nextValue()] = true;
        }
        while (res.size() < OpPerTxn) {
            res[m_uniformRowIds[threadId](*GetThreadLocalRandomGenerator())] = false;
        }
        return std::vector<std::pair<RowId, bool>>(res.begin(), res.end());
    }

private:
    ScrambledZipfianGenerator *m_skewRowId;
    std::vector<std::uniform_int_distribution<RowId>> m_uniformRowIds;  // not sure threadsafe
    const YcsbTableParam m_tableParam;
    const YcsbRunParam m_runParam;
};
class CachedRowIdGenerator : boost::noncopyable {
public:
    CachedRowIdGenerator(ScrambledZipfianGenerator *szipfian, const YcsbTableParam &tableParam,
                         const YcsbRunParam &runParam)
        : gen(szipfian, tableParam, runParam),
          CacheSize(ExpectedTps * (runParam.WarmUpSec + runParam.RunSec)),
          CacheSizePerThread(CacheSize / runParam.Terminal),
          m_cache(runParam.Terminal),
          m_cacheiter(runParam.Terminal, 0)
    {
        LOG(INFO) << "begin generating transactions.";
        std::vector<std::thread> initThreads(runParam.Terminal);
        for (size_t threadId = 0; threadId < runParam.Terminal; threadId++) {
            initThreads[threadId] = std::thread([this, threadId]() {
                GetThreadLocalRandomGenerator()->seed(std::random_device{}());
                auto &cache = m_cache[threadId];
                cache.reserve(CacheSizePerThread);
                for (size_t i = 0; i < CacheSizePerThread; i++) {
                    cache.emplace_back(gen(threadId));
                }
            });
        }
        for (auto &initThread : initThreads) {
            initThread.join();
        }
        LOG(INFO) << "cached " << CacheSize << "transactions";
    }
    std::vector<std::pair<RowId, bool>> operator()(size_t threadId)
    {
        auto &iter = m_cacheiter[threadId];
        auto &cache = m_cache[threadId];
        CHECK(iter < cache.size());
        std::vector<std::pair<RowId, bool>> ret(std::move(cache.at(iter)));
        ++iter;
        return ret;
    }

private:
    static constexpr size_t ExpectedOps = 30000000;  // should be greater than actual tps.
    static constexpr size_t ExpectedTps = ExpectedOps / OpPerTxn;
    const size_t CacheSize;
    const size_t CacheSizePerThread;
    UnCachedRowIdGenerator gen;
    std::vector<std::vector<std::vector<std::pair<RowId, bool>>>> m_cache;
    std::vector<size_t> m_cacheiter;
};
}  // namespace YCSB
}  // namespace NVMDB